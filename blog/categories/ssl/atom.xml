<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: SSL | alvin hu]]></title>
  <link href="http://alvinhu.com/blog/categories/ssl/atom.xml" rel="self"/>
  <link href="http://alvinhu.com/"/>
  <updated>2013-07-27T02:58:47+08:00</updated>
  <id>http://alvinhu.com/</id>
  <author>
    <name><![CDATA[alvinhu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[通过SSL Pinning提高iOS应用的安全性]]></title>
    <link href="http://alvinhu.com/blog/2013/06/26/secure-ios-apps-on-ssl-pinning/"/>
    <updated>2013-06-26T22:47:00+08:00</updated>
    <id>http://alvinhu.com/blog/2013/06/26/secure-ios-apps-on-ssl-pinning</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>关于SSL Pinning的技术在国外有很多文章提到，但是还没有找到一篇相关的中文文档。因为在开发中碰到这个问题，所以查阅了很多相关文章，在此基于自己对SSL Pinning的理解，再融合一些其他资料，整理了一下写了这么一篇文章，既给自己做个备份，也给大家做个参考。写的好的给个掌声，写的不好请留言指正。</p>

<h2>背景</h2>

<p>在开发Client-Server架构的手机应用时，如果问到如何提高数据传输的安全性，肯定很多程序员第一时间会回答TLS/SSL。确实，对比普通的HTTP协议数据传输，SSL可以大大提高数据的安全性，因为所有传输过程中的数据都是经过加密的。如果用户在机场、咖啡厅等开放式的wifi环境下使用应用，就算有攻击者通过技术手段截取了客户端与服务器之间传输的数据，对于他们来说也不过是一些加密过的垃圾。</p>

<p>表面上看这样已经足够安全了，但是危险就在身边。虽然SSL解决了内容加密的问题，但是在这个兵火战乱的年代，和你通信的是不是真正的服务器呢？就算对方能够提供证书，这年头证书也可以伪造，<a href="http://tech.sina.com.cn/i/2011-08-31/12096005012.shtml">2011年就爆发了一次大规模的SSL证书安全攻击，受牵连的公司包括谷歌</a>。</p>

<p><img src="/images/secure-ios-apps-on-ssl-pinning/github-get-attacked.jpg" alt="GitHub被攻击" /></p>

<p>下面我们介绍为什么有了证书用了加密还会被攻击吧！</p>

<!-- more -->


<h2>中间人攻击</h2>

<p>中间人攻击（Man-in-the-middle Attack，简称MITM、MitM、MIM、MiM、MITMA）是一种由来已久的网络入侵手段，并且在今天仍然有着广泛的发展空间，如SMB会话劫持、DNS欺骗等攻击都是典型的中间人攻击。简而言之，所谓的中间人攻击就是通过拦截正常的网络通信数据，并进行数据篡改和嗅探，而通信的双方却毫不知情。</p>

<p>具体中间人攻击的定义、方法和防御措施等可以参考<a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">维基百科</a>或者<a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">百度百科</a>。以下两个故事用来说明中间人攻击的大致流程。</p>

<hr />

<h3>西方言情简化版</h3>

<p>从前有一枚高富帅叫杰克，女友是白富美女神爱丽丝，却苦于天各一方，只能求书信往来以解相思之苦。奈何时局动荡、人心不古，觊觎女神者比比皆是。书信若为明文，定要被那中转信件的屌丝皮特拆看，而后从中作祟，行不轨之事。</p>

<p>于是杰克与爱丽丝商定，从今而后，爱丽丝给杰克的书信均以密文誊写，再附以特制封签，杰克收到密信后可凭此封签在一公证可信之处验明此信是否确为爱丽丝所发。</p>

<p>商定完毕，二人书信往来再非明文。皮特拆看无果，甚是捉急，情急之下心生一计：既然无法看到爱丽丝的密信内容，不如索性截下来信，自行伪造一封转交杰克，再设法从他那套取消息？</p>

<p>打定主意，皮特翻看了一下手中爱丽丝给杰克的一封密信：</p>

<pre><code>封签：ecaa5d137be9468d98379ada45919d80
从哪来：爱丽丝
打哪去：杰克

[正文已加密]
</code></pre>

<p>皮特旋即扣下了这封信，伪造了另外一封交给杰克：</p>

<pre><code>封签：718fe14088974488b821f8c9d8f14849
从哪来：爱丽丝
打哪去：杰克

亲爱的，上次你给我说你的银行卡帐号密码是多少来着？我一下忘记了。急用！

附：回信记得用密码「此地无银三百两」加密哟！
</code></pre>

<p>杰克收到篡改的信件后，看到爱丽丝急于盼复，未经细察，便回信告知了银行卡帐号密码。于是就悲剧了……</p>

<p>这就是最基础的中间人攻击。杰克如果谨慎一点，每次收到密信时都去那公证可信之处验证一下封签，确认信件是由爱丽丝所发，上面的悲剧就不会发生。</p>

<p>不过道高一尺、魔高一丈，皮特若能控制那公证可信之处，待杰克去验证时就可以做手脚，让杰克误以为伪造密信确为爱丽丝所发，于是继续悲剧……这种手法叫做伪造证书。</p>

<p>从这个故事可以看出中间人攻击就是躲在中间的小人，让通信的双方误以为跟自己通信的就是TA，而小人在中间获取双方的重要信息。</p>

<hr />

<h3>三国通信加强版</h3>

<p>上面的故事虽然生动，但是与真正的SSL原理有一定出入，这是为了更容易理解。实际上通过SSL加密通信，一旦会话初始化完成，想要完成中间人攻击是非常困难的。TLS的中间人攻击是针对加密会话的初始化阶段进行的，而不是实际通信的阶段。加密通信的初始化阶段，需要通过非对称密码算法来协商密钥，然后用协商好的密钥，使用对称加密算法进行实际的通信。</p>

<p>不知道各位有没有见过一种锁，当用钥匙打开这种锁之后，钥匙就可以拔出来了，剩下一个开着的锁头。拿着这个开着的锁，没有钥匙，一旦锁上了就开不了。这是现实生活中的一种非对称加密的物件，能上锁，但是不能开锁。</p>

<p>现在故事开始，假设我们回到了三国时代，孙权需要和刘备通信，而且通信的内容必须要保密。于是负责接收消息的简雍想出来一个办法，找了一把上面说的那种锁（公钥），我们给它取名甲锁，先用钥匙打开，然后送给孙权。孙权在通信之前，需要找到另外一把有两个钥匙的锁（对称加密算法），我们给它取名乙锁，然后把这把乙锁和其中一把乙锁钥匙（对称密钥），放进一个无法被破拆的铁盒子里面，用简雍提供的那把开着的甲锁把铁盒子锁上。</p>

<p>这时候，这个铁盒子就无法打开了，除了拥有甲锁钥匙的简雍。这个装有乙锁和一把乙锁钥匙的铁盒子，可以放心地交到任何一个人手上，然后让他拿去给简雍。简雍拿到这个铁盒子之后，加密通信会话就建立了。他就会用甲锁钥匙打开铁盒子，取出乙锁和乙锁钥匙。刘备写下“亲，你好，我是刘备”的小纸条，放进铁盒子里，然后简雍用乙锁把铁盒子锁上，然后交回到孙权的手上。这个时候，铁盒子被孙权提供的乙锁锁上了，除了孙权和简雍，没有别人有钥匙能够打开这个铁盒子，铁盒子也就可以安全地经过邮差送到孙权的手上；孙权收到铁盒子之后，用自己的乙锁钥匙打开乙锁，读取铁盒子里面的消息，然后放进新的小纸条，再寄送回去。</p>

<p>以上是加密通信的过程。</p>

<p>接下来，别有用心的曹操出现了，他先冒充孙权的人向简雍要来了打开的甲锁。当孙权需要和刘备通信的时候，曹操再递给孙权一把他自己的丙锁，骗孙权说这把是简雍的甲锁。当孙权把自己的乙锁和乙锁钥匙放进去，交给曹操让他把这些送给简雍的时候，曹操就可以找到另外一个铁盒子，装上自己另外一把有两把钥匙的丁锁和其中一把丁锁钥匙，用真正的简雍提供的甲锁锁上，然后寄给简雍。简雍依然会正常的收到一个铁盒子，里面装着丁锁和一把丁锁钥匙，只不过，这个锁已经不是孙权的了，而是曹操的，孙权的那把乙锁实际上在曹操手上。简雍把“亲，你好，我是刘备”的小纸条放进铁盒，然后让曹操带回去给孙权，而这个时候，曹操就可以打开这个小铁盒，偷看他们之间的消息，然后自己编造一条消息，放进铁盒里面，然后传回去给孙权。</p>

<p>以上是中间人攻击。</p>

<p>为了避免中间人攻击，聪明的简雍，发明了一种神奇的、无法撕毁、涂改和变造的小纸条（数字签名），上面写着“这把锁经过简雍认证，是刘备加密通信专用锁”，然后贴在甲锁上，这样子曹操就不能伪造锁了，这时候这个锁叫作证书。</p>

<p>但是问题又来了，许多人不认识简雍，他们怎么知道简雍就是可信的，他认证的锁就是可用的？于是关羽在这个小纸条的下方又贴了一个小纸条，“简雍经过关羽的认证，可以对刘备加密通信专用锁进行认证”。关羽不仅可以认证锁，还可以认证简雍的权力，这时候关羽就是CA。可是问题还没有解决，还是有很多傻瓜不认识关羽，于是诸葛亮又在关羽的小纸条上又贴了一个小纸条，“关羽经过诸葛亮的认证，可以对刘备加密通信专用锁进行认证”。问题依然没有解决，还是有白痴不认识诸葛亮，于是这时候需要一个权威的、人们无条件相信的人——汉献帝来对诸葛亮进行认证，这就是根CA，他贴上去的小纸条就叫作根证书。</p>

<p>以上是信任体系。</p>

<p>最后一个问题，SSL的中间人攻击怎么实施。这时候糜芳出场了，因为是刘备的手下，具有一个可信的证书，类似于“糜芳经过关羽的认证，可以对刘备加密通信专用锁进行认证”。于是他自己伪造了一个锁，然后利用上一级CA对他的信任，去骗取孙权使用他提供的锁初始化加密会话。因为他的锁上面有上一级CA的认证，所以孙权会认为这个锁是可信的，而实际上糜芳通过自己拥有的证书，可以实施中间人攻击，窃取孙权和刘备之间通信的内容。</p>

<p>以上便是SSL的中间人攻击。可以看出，SSL的中间人攻击是比较复杂的，一般利用的是上一级可信CA颁发一个伪造证书来进行攻击。</p>

<h2>解决方案</h2>

<p>SSL Pinning（又叫Certificate Pinning）可以理解为证书绑定。在一些应用场景中，客户端和服务器之间的通信是事先约定好的，既服务器地址和证书是预先知道的，这种情况常见于CS架构的应用中。这样的话在客户端事先保存好一份服务器的证书（含公钥），每次请求服务器的时候，将服务器返回的证书与客户端保存的证书进行对比，如果证书不符，说明受到中间人攻击，马上可以中断请求。这样的话中间人就无法伪造证书进行攻击了。</p>

<p>接着前面的故事，为了防范曹操各种手段的攻击，简雍派亲信送给孙权一把贴有简雍认证的小纸条的甲锁，然后告诉孙权，这才是真正的小纸条和甲锁，凡是跟这不一样的锁都是假的。过不了几天，孙权想给刘备写信了，糜芳拿着一个贴着“糜芳经过关羽的认证，可以对刘备加密通信专用锁进行认证”小纸条的戊锁来了，孙权一比对发现跟简雍给自己的甲锁不一样，勃然大怒，又是一个奸细，给我退出去斩了。从此，孙权和刘备可以安全快乐的进行通信了。</p>

<p>SSL Pinning可以很好的解决中间人攻击的问题，但是仅限于在客户端预先知道服务器地址和证书的场景下。如果是在服务器地址未知如需要用户手动输入服务器url的场景中，SSL Pinning就无法发挥作用了。</p>

<p>在我开发的一个iOS项目中使用了AFNetworking做为网络应用层，AFNetworking已经很好的支持了SSL Pinning。使用起来非常简单！</p>

<ul>
<li>首先在Prefix.pch文件最后加上：</li>
</ul>


<p>```</p>

<h1>define <em>AFNETWORKING_PIN_SSL_CERTIFICATES</em></h1>

<p>```</p>

<p>如果是自签名的证书还需要加上：</p>

<p>```</p>

<h1>define <em>AFNETWORKING_ALLOW_INVALID_SSL_CERTIFICATES</em></h1>

<p>```
否则在请求服务器的时候会弹出提示框说该服务器证书为不可信任的机构颁发</p>

<ul>
<li>然后把服务器证书添加到应用中，证书文件取什么名字无所谓，后缀必须是cer，并且是DER编码的证书</li>
</ul>


<p>如何制作自签名证书和转换DER编码证书文件（补充章节）可以查看我之前的一篇文章：<a href="/blog/2013/06/12/creating-a-certificate-authority-and-signing-the-ssl-certificates-using-openssl-in-iis8/">IIS8中使用OpenSSL来创建CA并且签发SSL证书</a></p>

<ul>
<li>最后在AFHTTPClient的继承类中加上一行代码：</li>
</ul>


<p><code>
[self setDefaultSSLPinningMode:AFSSLPinningModePublicKey];
</code></p>

<p>具体位置参考如下：</p>

<p>```</p>

<h1>import &ldquo;HPAPIClient.h&rdquo;</h1>

<h1>import &ldquo;AFHTTPRequestOperationLogger.h&rdquo;</h1>

<p>@implementation HPAPIClient</p>

<ul>
<li><p>(HPAPIClient <em>)sharedClient
{
  static HPAPIClient </em>sharedClient = nil;
  static dispatch_once_t onceToken;</p>

<p>  dispatch_once(&amp;onceToken, ^{
      sharedClient = [[HPAPIClient alloc] initWithBaseURL:[NSURL URLWithString:kAPIBaseURL]];
  });
  return sharedClient;
}</p></li>
<li><p>(id)initWithBaseURL:(NSURL *)URL
{
  self = [super initWithBaseURL:URL];
  if (self) {
      [self registerHTTPOperationClass:[AFJSONRequestOperation class]];
      [self setDefaultHeader:@&ldquo;Accept&rdquo; value:@&ldquo;application/json&rdquo;];
      [self setDefaultSSLPinningMode:AFSSLPinningModePublicKey];
  }
  return self;
}
&hellip;
```</p></li>
</ul>


<h2>总结</h2>

<p>有了SSL＋SSL Pinning，在开发CS架构的应用中就可以大大提高网络数据传输的安全性，简化程序开发中其他的一些安全措施。我自己是感觉方便安全多了！</p>

<h2>References</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-in-the-middle attack</a></li>
<li><a href="http://baike.baidu.com/view/1531871.htm">中间人攻击</a></li>
<li><a href="http://www.zhihu.com/question/20744215">什么是 TLS 中间人攻击</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSL的单向认证和双向认证]]></title>
    <link href="http://alvinhu.com/blog/2013/06/20/one-way-and-two-way-ssl-authentication/"/>
    <updated>2013-06-20T12:28:00+08:00</updated>
    <id>http://alvinhu.com/blog/2013/06/20/one-way-and-two-way-ssl-authentication</id>
    <content type="html"><![CDATA[<p>为了便于更好的认识和理解SSL协议，这里着重介绍SSL协议的握手流程。SSL协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL的握手流程非常有效的让客户端和服务器之间完成相互之间的身份认证。</p>

<!-- more -->


<h3>SSL握手流程</h3>

<ol>
<li>客户端向服务器发送ClientHello消息，说明它支持的最高TLS协议版本，随机数、密码算法列表及压缩方法。</li>
<li>服务器回复ServerHello消息，包含基于客户端ClientHello消息所选择的TLS协议版本，随机数、密码算法列表及压缩方法。服务器选择的协议版本为客户端和服务器都支持的最高版本。</li>
<li>当双方知道了连接参数，服务器向客户端发送证书。</li>
<li>客户端验证服务器证书的合法性，包括：服务器证书是否过期、发行服务器证书的CA是否可靠、发行CA的公钥能否正确解开服务器证书的发行CA的数字签名、服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第5步。</li>
<li>客户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤3中的服务器证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</li>
<li>如果服务器要求客户端的身份认证（在握手过程中为可选），客户端可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户端自己的证书以及加密过的“预主密码”一起传给服务器。</li>
<li>如果服务器要求客户端的身份认证，服务器必须检验客户端证书和签名随机数的合法性，具体的合法性验证包括：客户端证书是否过期，发行客户端证书的CA是否可靠，发行CA的公钥能否正确解开客户端证书的发行CA的数字签名，检查客户端证书是否在证书废止列表（CRL）中。如果合法性验证没有通过，通讯立刻中断；如果合法性验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</li>
<li>服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL协议的安全数据通讯的加解密通讯。同时在SSL通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</li>
<li>客户端向服务器发出信息，指明后面的数据通讯将使用的步骤8中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</li>
<li>服务器向客户端发出信息，指明后面的数据通讯将使用的步骤8中的主密码为对称密钥，同时通知客户端服务器的握手过程结束。</li>
<li>SSL的握手部分结束，SSL安全通道的数据通讯开始，客户端和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</li>
</ol>


<h3>单向认证vs双向认证</h3>

<p>上面所述的是<strong>双向认证SSL协议</strong>的具体通讯过程，这种情况要求服务器和客户端双方都有证书。<strong>单向认证SSL协议</strong>不需要客户端拥有CA证书，具体的流程相对于上面的步骤，只需将服务器验证客户端证书的步骤去掉，以及在协商对称密码方案，对称通话密钥时，服务器发送给客户端的是没有加过密的（这并不影响SSL过程的安全性）密码方案。这样，双方具体的通讯内容，就是加密过的数据。如果有第三方攻击，获得的只是加密的数据，第三方要获得有用的信息，就需要对加密的数据进行解密，这时候的安全就依赖于密码方案的安全。而幸运的是，目前所用的密码方案，只要通讯密钥长度足够的长，就足够的安全。这也是我们强调要求使用128位加密通讯的原因。</p>

<p>一般Web应用都是采用单向认证的，原因很简单，用户数目广泛，且无需做在通讯层做用户身份验证，一般都在应用逻辑层来保证用户的合法登入。但如果是企业应用对接，情况就不一样，可能会要求对客户端（相对而言）做身份验证。这时就需要做双向认证。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IIS8中使用OpenSSL来创建CA并且签发SSL证书]]></title>
    <link href="http://alvinhu.com/blog/2013/06/12/creating-a-certificate-authority-and-signing-the-ssl-certificates-using-openssl-in-iis8/"/>
    <updated>2013-06-12T00:49:00+08:00</updated>
    <id>http://alvinhu.com/blog/2013/06/12/creating-a-certificate-authority-and-signing-the-ssl-certificates-using-openssl-in-iis8</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>最近在为新的iOS app考虑安全机制，第一个进入脑海里的就是HTTPS和SSL。所以研究了一下Windows服务器下IIS部署HTTPS和证书的方法，以及如何让app与server进行安全的信息交互。</p>

<p>由于网上千篇一律的只是教大家怎么怎么操作，并没有告诉大家为什么这么操作。而作为一个喜欢打破砂锅问到底的强迫症患者，自己又花了一些时间研究了各个步骤及参数的原理，在这里把这些小小的理解及经验记录下来，即给有同样需求的同行们做个参考，也给未来的自己留作备份。</p>

<p>欢迎转载，转载请保留原文地址。</p>

<!-- more -->


<h2>申明</h2>

<p>本人并非互联网安全专家，也不是OpenSSL老手。如果这篇文章对你有用，本人非常高兴。如果无法解决问题，你可以google其他更专业的文章，我相信只要花点时间肯定能够找到答案。本文中所有步骤都经过本人多次测试，但不能保证一定正确，在此仅供参考。如有不对之处，欢迎留言探讨及指正。</p>

<h2>准备</h2>

<ul>
<li>Windows 8 + IIS 8</li>
<li>直接下载编译好的<a href="http://slproweb.com/products/Win32OpenSSL.html">OpenSSL</a>，由于我的系统是64位的，所以我下的是最新版的<code>Win64 OpenSSL v1.0.1e Light</code></li>
<li>安装OpenSSL之前要先装<code>Visual C++ 2008 SP1 Redistributables</code>，根据系统选择<a href="http://www.microsoft.com/zh-cn/download/details.aspx?id=5582">32位</a>的和<a href="http://www.microsoft.com/zh-cn/download/details.aspx?id=2092">64位</a>下载并安装</li>
</ul>


<h2>开始</h2>

<h3>第一步：安装OpenSSL</h3>

<ol>
<li>尽管我们已经安装了<code>Visual C++ 2008 SP1 Redistributables</code>，安装刚开始还是会提示未安装<code>Visual C++ 2008 Redistributables</code>，不管它直接点击确定</li>
<li>一路下一步就可以了，安装文件夹我选择<code>C:\OpenSSL</code></li>
<li>在<code>Copy OpenSSL DLLs to:</code>的地方我选择<code>The OpenSSL binaries (/bin) directory</code>，我不喜欢把什么DLL都往Windows目录丢，这样放在应用程序目录下比较干净</li>
<li>完成安装</li>
</ol>


<h3>第二步：配置OpenSSL</h3>

<p>1、将路径<code>C:\OpenSSL\bin\</code>添加到系统路径中（控制面板 > 系统与安全 > 系统 > 高级系统设置 > 环境变量 > 系统变量 > Path），这样在任何路径中都能运行OpenSSL命令</p>

<p>2、打开openssl.cfg，修改一下配置：</p>

<pre><code>dir = . # 存放CA文件的文件夹，里面还需要手动建立子文件夹及件，后面会提到
default_days = 10950 # 证书有效期，设30年比较省心
policy = policy_anything # CA资料和证书申请资料的匹配策略改为这个比较方便
countryName_default = CN # 默认国家
stateOrProvinceName_default = Jiagxi # 默认省份
localityName_default = Nanchang # 默认城市，在localityName = Locality Name (eg,city)下增加这一条
0.organizationName_default = Kashuo # 默认组织
</code></pre>

<p>3、接着准备文件夹及文件：</p>

<ul>
<li>新建文件夹<code>C:\OpenSSL\bin\KashuoCA</code></li>
<li>新建文件夹<code>C:\OpenSSL\bin\KashuoCA\newcerts</code></li>
<li>新建文件<code>C:\OpenSSL\bin\KashuoCA\serial</code>（无后缀名），里面写入<code>01</code>，用来存放签发证书流水号</li>
<li>新建空文件<code>C:\OpenSSL\bin\KashuoCA\index.txt</code>，用来存放签发证书记录</li>
</ul>


<p>4、为了省去每次运行命令都要指定openssl.cfg的麻烦，打开命令提示符（cmd.exe），将cfg文件设为系统变量：</p>

<p><code>
set OPENSSL_CONF=C:\OpenSSL\bin\openssl.cfg
</code></p>

<p>5、重新打开命令提示符，进入KashuoCA文件夹：</p>

<p><code>
cd C:\OpenSSL\bin\KashuoCA
</code></p>

<p>准备好以后开始下面的步骤</p>

<h3>第三步：建立CA</h3>

<p>命令：</p>

<p><code>
openssl req -x509 -newkey rsa:1024 -keyout ca.key -out ca.cer
</code></p>

<p>参数：</p>

<pre><code>req # 用来生成PKCS#10格式的证书申请文件，也可以生成自签名的CA根证书
-x509 # 有这个参数就是生成CA根证书，没有就是生成证书申请文件
-newkey rsa:1024 # 同时生成1024位RSA算法的私钥
-keyout # CA私钥
-out # 证书申请文件或CA根证书
</code></pre>

<p>由于我们之前已经设置了证书有效期和cfg文件的地址，所以在命令里就不需要重复设置了</p>

<p>运行命令以后会要求输入私钥密码，并且再输入一次确认密码。在输入国家省份等资料的时候直接回车使用之前我们设置的默认值就可以了，但是在<code>Organizational Unit Name</code>、<code>Common Name</code>和<code>Email Address</code>三个地方没有设置默认值，因为这三个资料在CA证书和服务器证书里是不一样的。</p>

<pre><code>C:\OpenSSL\bin\KashuoCA&gt;openssl req -x509 -newkey rsa:1024 -keyout ca.key -out ca.cer
Loading 'screen' into random state - done
Generating a 1024 bit RSA private key
...........++++++
.........................++++++
writing new private key to 'ca.key'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [CN]:
State or Province Name (full name) [Jiangxi]:
Locality Name (eg, city) [Nanchang]:
Organization Name (eg, company) [Kashuo]:
Organizational Unit Name (eg, section) []:KashuoCA
Common Name (e.g. server FQDN or YOUR name) []:KashuoCA
Email Address []:ca@kashuo.com
</code></pre>

<p>这时候我们就有了CA根证书和私钥了！</p>

<h3>第四步：通过IIS生成证书申请文件</h3>

<p>由于本例中证书文件是部署在IIS中，所以通过IIS直接生成证书文件会比较方便。当然第二步中提到了通过OpenSSL的req方法也可以生成证书申请文件。</p>

<p>1、打开<code>IIS</code></p>

<p>2、在左侧<code>连接</code>中选择服务器</p>

<p>3、在中间<code>主页</code>里的<code>IIS</code>中选择<code>服务器证书</code></p>

<p>4、在右侧<code>操作</code>中选择<code>创建证书申请</code></p>

<p>5、在打开的窗口中填入以下信息：</p>

<pre><code>通用名称：www.kashuo.com
组织：Kashuo
组织单位：KashuoServer
城市/地点：Nanchang
省/市/自治区：Jiangxi
国家/地区：CN
</code></pre>

<p>通用名称里填写的域名要与该证书所绑定的网站域名一致，否则用户在浏览网站的时候会提示证书与域名不一致</p>

<p>6、加密服务选择RSA和1024位</p>

<p>7、最后保存证书申请的文件为<code>C:\OpenSSL\bin\KashuoCA\certreq.txt</code></p>

<h3>第五步：签发服务器证书</h3>

<p>现在，CA证书文件ca.cer、CA私钥ca.key、服务器证书申请certreq.txt三个文件都在KashuoCA文件夹下</p>

<p>命令：</p>

<p><code>
openssl ca -in certreq.txt -cert ca.cer -keyfile ca.key -out iis.cer
</code></p>

<p>参数：</p>

<pre><code>ca # 主要用来签发证书申请
-in # 证书申请文件
-cert # CA证书
-keyfile # CA私钥
-out # 签发的证书
</code></pre>

<p>运行命令以后需要输入CA的私钥密码</p>

<pre><code>C:\OpenSSL\bin\KashuoCA&gt;openssl ca -in certreq.txt -cert ca.cer -keyfile ca.key -out iis.cer
Using configuration from C:\OpenSSL\bin\openssl.cfg
Loading 'screen' into random state - done
Enter pass phrase for ca.key:
Check that the request matches the signature
Signature ok
Certificate Details:
        Serial Number: 1 (0x1)
        Validity
            Not Before: Jun 13 10:32:25 2013 GMT
            Not After : Jun  6 10:32:25 2043 GMT
        Subject:
            countryName               = CN
            stateOrProvinceName       = Jiangxi
            localityName              = Nanchang
            organizationName          = Kashuo
            organizationalUnitName    = KashuoServer
            commonName                = www.kashuo.com
        X509v3 extensions:
            X509v3 Basic Constraints:
                CA:FALSE
            Netscape Comment:
                OpenSSL Generated Certificate
            X509v3 Subject Key Identifier:
                E0:8A:69:4A:D1:0A:98:26:EA:AE:AF:5E:6D:A7:A7:C4:DE:07:13:DF
            X509v3 Authority Key Identifier:
                keyid:37:48:69:62:0E:FD:FB:1E:83:EB:DE:2D:0D:F6:55:C1:E1:76:EF:BA

Certificate is to be certified until Jun  6 10:32:25 2043 GMT (10950 days)
Sign the certificate? [y/n]:y


1 out of 1 certificate requests certified, commit? [y/n]y
Write out database with 1 new entries
Data Base Updated
</code></pre>

<p>最后我们得到了服务器证书<code>iis.cer</code></p>

<h3>第六步：在服务器上导入CA根证书</h3>

<p>由于第三步生成的CA根证书是自签名的，并非由系统可以识别的第三方信任机构签发，所以需要将CA根证书导入到服务器中。</p>

<ol>
<li>双击<code>ca.cer</code>打开证书详情</li>
<li>点击<code>安装证书</code>打开<code>证书导入向导</code></li>
<li>存储位置选择<code>本地计算机</code>然后下一步</li>
<li>选择<code>将所有的证书都放入下列存储</code></li>
<li>点击浏览，选择<code>受信任的根证据颁发机构</code></li>
<li>导入完成</li>
</ol>


<h3>第七步：完成IIS证书申请</h3>

<p>现在可以将第五步生成的<code>iis.cer</code>导入到IIS中了：</p>

<ol>
<li>点击第四步<code>创建证书申请</code>下方的<code>完成证书申请</code></li>
<li>选择证书文件：<code>C:\OpenSSL\bin\KashuoCA\iis.cer</code></li>
<li>输入一个好记名称，如<code>www.kashuo.com</code></li>
<li>证书存储默认<code>个人</code></li>
<li>点击确定完成证书导入</li>
</ol>


<p>这个时候在服务器证书列表里就可以看到这个证书了。</p>

<h3>第八步：打开网站的SSL设置</h3>

<p>安装好IIS证书以后就可以打开网站的SSL设置了：</p>

<ol>
<li>在IIS左侧<code>连接</code>中选择<code>网站</code></li>
<li>在右侧<code>操作</code>中点击<code>绑定</code></li>
<li>在打开的<code>网站绑定</code>中添加一条记录：

<ul>
<li><code>类型</code>选择<code>https</code></li>
<li><code>主机名</code>填写绑定的域名，如<code>www.kashuo.com</code></li>
<li><code>证书</code>就选择我们刚刚添加的证书</li>
<li>确定完成</li>
</ul>
</li>
<li>然后在中间<code>主页</code>里的<code>IIS</code>中选择<code>SSL设置</code>，这里根据自己的需求进行设置

<ul>
<li><code>要求SSL</code>：勾选以后只能通过https访问，否则http和https都可以访问</li>
<li><code>客户证书</code>：

<ul>
<li>忽略：不论客户端有没有证书都不检验</li>
<li>接受：如果客户端没有证书就不检验，否则弹出提示框让用户选择证书并检验证书合法性</li>
<li>必需：客户端必需提供合法证书才能进行访问</li>
</ul>
</li>
</ul>
</li>
<li>设置完成以后点击右边<code>应用</code>就可以了</li>
</ol>


<p>对于<a href="/blog/2013/06/20/one-way-and-two-way-ssl-authentication/">单向认证SSL</a>连接，在<code>客户证书</code>里选择<code>忽略</code>就可以，教程到这里也就结束了。客户端在访问https地址的时候会收到一个提示，即服务器证书并非由信任的第三方证书颁发机构颁发，客户端选择继续或者保存为信任的证书就可以继续访问了。</p>

<p>如果对于安全性要求很高的网站，需要使用<a href="/blog/2013/06/20/one-way-and-two-way-ssl-authentication/">双向认证SSL</a>连接，在<code>客户证书</code>里就要选择<code>必需</code>，即服务端和客户端互相验证对方证书的合法性。那就还需要为客户端生成一个服务端认可的证书。</p>

<h3>第九步：生成客户端证书申请文件</h3>

<p>命令：</p>

<p><code>
openssl req -newkey rsa:1024 -keyout client.key -out client.csr
</code></p>

<p>参数：</p>

<pre><code>req # 用来生成PKCS#10格式的证书申请文件，也可以生成自签名的CA根证书
-newkey rsa:1024 # 同时生成1024位RSA算法的私钥
-keyout # 证书私钥
-out # 证书申请文件
</code></pre>

<p>细心的你可能发现这个命令和第三步建立CA的命令差不多，区别是少了<code>-x509</code>参数和输出的是证书申请文件。
运行命令以后输入两次客户端私钥密码，然后就是客户端的一些基本信息。最后的<code>A challenge password</code>和<code>An optional company name</code>不是必填的，我就直接回车跳过了。</p>

<pre><code>C:\OpenSSL\bin\KashuoCA&gt;openssl req -newkey rsa:1024 -keyout client.key -out client.csr
Loading 'screen' into random state - done
Generating a 1024 bit RSA private key
........++++++
...++++++
writing new private key to 'client.key'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [CN]:
State or Province Name (full name) [Jiangxi]:
Locality Name (eg, city) [Nanchang]:
Organization Name (eg, company) [Kashuo]:
Organizational Unit Name (eg, section) []:KashuoApp
Common Name (e.g. server FQDN or YOUR name) []:Client
Email Address []:client@kashuo.com

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
</code></pre>

<h3>第十步：签发客户端证书</h3>

<p>命令：</p>

<p><code>
openssl ca -in client.csr -cert ca.cer -keyfile ca.key -out client.cer
</code></p>

<p>参数：</p>

<pre><code>ca # 主要用来签发证书申请
-in # 证书申请文件
-cert # CA证书
-keyfile # CA私钥
-out # 签发的证书
</code></pre>

<p>签发客户端证书和签发服务器证书的命令是一样的。运行命令以后同样需要输入CA的私钥密码</p>

<pre><code>C:\OpenSSL\bin\KashuoCA&gt;openssl ca -in client.csr -cert ca.cer -keyfile ca.key -out client.cer
Using configuration from C:\OpenSSL\bin\openssl.cfg
Loading 'screen' into random state - done
Enter pass phrase for ca.key:
Check that the request matches the signature
Signature ok
Certificate Details:
        Serial Number: 2 (0x2)
        Validity
            Not Before: Jun 20 14:03:18 2013 GMT
            Not After : Jun 13 14:03:18 2043 GMT
        Subject:
            countryName               = CN
            stateOrProvinceName       = Jiangxi
            localityName              = Nanchang
            organizationName          = Kashuo
            organizationalUnitName    = KashuoApp
            commonName                = Client
            emailAddress              = client@kashuo.com
        X509v3 extensions:
            X509v3 Basic Constraints:
                CA:FALSE
            Netscape Comment:
                OpenSSL Generated Certificate
            X509v3 Subject Key Identifier:
                44:C7:B1:DA:5E:36:34:8C:6F:37:17:82:BB:F2:CD:AC:69:1A:3F:41
            X509v3 Authority Key Identifier:
                keyid:FE:79:C3:FF:9E:4F:AA:AA:8F:BD:03:19:1A:02:CD:60:27:FB:98:67

Certificate is to be certified until Jun 13 14:03:18 2043 GMT (10950 days)
Sign the certificate? [y/n]:y

1 out of 1 certificate requests certified, commit? [y/n]y
Write out database with 1 new entries
Data Base Updated
</code></pre>

<p>client.cer就是客户端证书了</p>

<h3>第十一步：将客户端证书转换为PKCS#12格式</h3>

<p>命令：</p>

<p><code>
openssl pkcs12 -export -clcerts -in client.cer -inkey client.key -out client.p12
</code></p>

<p>参数：</p>

<pre><code>pkcs12 # 生成或解析PKCS#12证书
-export # 生成证书
-clcerts # 输出客户端证书
-in # 原证书
-inkey # 私钥
-out # 转换后证书
</code></pre>

<p>先输入客户端证书私钥密码，然后输入两次p12文件的导出密码</p>

<pre><code>C:\OpenSSL\bin\KashuoCA&gt;openssl pkcs12 -export -clcerts -in client.cer -inkey client.key -out client.p12
Loading 'screen' into random state - done
Enter pass phrase for client.key:
Enter Export Password:
Verifying - Enter Export Password:
</code></pre>

<p>client.p12包含客户端证书和私钥，支持浏览器直接导入，最后一步就是导入p12证书了。</p>

<h3>第十二步：导入客户端证书</h3>

<p>在客户端电脑导入客户端证书之前需要先导入CA根证书，将第三步生成的CA根证书文件拷贝到客户端电脑里，按照第六步的流程导入CA根证书。</p>

<p>接着安装客户端证书，这个就比较简单了：</p>

<ol>
<li>双击client.p12打开证书详情</li>
<li>存储位置默认<code>当前用户</code></li>
<li>输入p12文件的导出密码</li>
<li>根据个人需要勾选是否可导出密钥</li>
<li><code>自动选择证书存储</code>就可以</li>
<li>大功告成！</li>
</ol>


<p>当导入客户端完成以后，客户端与服务器的双向认证SSL就搞定了！</p>

<h2>补充：</h2>

<p>PEM编码证书转换为DER编码证书</p>

<p>命令：</p>

<p><code>
openssl x509 -outform der -in iis.cer -out iisder.cer
</code></p>

<p>参数：</p>

<pre><code>x509 # x509证书管理
-outform der # 转换为DER编码
-in # 原证书
-out # 转换后证书
</code></pre>

<p>目前我在iOS开发中使用了AFNetworking，在做<code>SSL Pinning</code>的时候读取服务器证书要求证书编码为DER，而第五步生成的证书编码为PEM，所以需要用这个命令转换一下。</p>

<p>关于SSL Pinning可以查看我另一片文章：<a href="/blog/2013/06/26/secure-ios-apps-on-ssl-pinning/">通过SSL Pinning提高iOS应用的安全性</a></p>

<h2>总结</h2>

<p>通过这次的CA安装和签发证书的学习，弄清了通过SSL提高网络请求安全性的基本原理，也明白了证书到底是个什么东西。其实只要有心，没有什么是深不可测的。</p>

<p>当然自签名CA根证书只是一个临时解决方案，也是学习概念和理论的好途径，如果在大型应用并且不差钱话还是去可信任的CA机构购买证书吧！全文完！</p>

<h2>References</h2>

<ul>
<li><a href="http://www.openssl.org/docs/">OpenSSL Documents</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
